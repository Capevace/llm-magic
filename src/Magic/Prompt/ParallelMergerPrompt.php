<?php

namespace Mateffy\Magic\Prompt;

use Mateffy\Magic\Config\Extractor;
use Mateffy\Magic\Functions\Extract;
use Mateffy\Magic\Functions\InvokableFunction;
use Mateffy\Magic\LLM\Message\TextMessage;

class ParallelMergerPrompt implements Prompt
{
    public function __construct(
        protected Extractor $extractor,
        protected array $datas,

        public bool $shouldForceFunction = true,
    ) {}

    public function system(): string
    {
        $schema = json_encode(
            $this->extractor->schema,
            JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES | JSON_THROW_ON_ERROR | JSON_PRETTY_PRINT
        );

        return <<<PROMPT
        <instructions>
        You are a structured data merger.
        You are given a list of JSON objects that you need to merge into one JSON object.
        These JSON objects have been generated by a structured data extractor LLM, which got the data from files and other sources.
        Each JSON object follows the same specific schema, which is the same that you have been given.
        The data they've output may be incomplete, as they may have only seen a subset of the source documents.
        This is where you come in. It is your job to merge this data into one JSON object.
        IT IS IMPORTANT THAT THE DATA SCHEMA STAYS THE SAME. DO NOT INVENT ANY FIELDS. DO NOT REMOVE ANY FIELDS UNLESS IT MAKES FULL SENSE AND IS COMPLIANT WITH THE SCHEMA.

        The difficult task you are facing is making sure the data is merged correctly. This is difficult as the documents may not reference the same entities.
        For example one LLM may have looked at document A containing product A and B, and another LLM may have looked at document B containing only product B.
        If you merge these two documents dumbly, you may end up with just one or three product entities, which is not correct.
        So, you'll need to identify entities as best as you can, and then merge them correctly.

        You are given the notes that were used to create the JSON object. These contain info that was relevant when generating the output, and may be helpful in understanding the data.
        </instructions>

        <json-schema>
        {$schema}
        </json-schema>

        <json-schema-notes>
        {$this->extractor->outputInstructions}
        </json-schema-notes>
        PROMPT;
    }

    public function prompt(): string
    {
        $jsonObjects = collect($this->datas)
            ->filter()
            ->map(fn (array $data) => json_encode($data, JSON_THROW_ON_ERROR | JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE))
            ->map(fn (string $json) => "<json-object>{$json}</json-object>")
            ->join("\n");

        return <<<TXT
        <json-objects>
        {$jsonObjects}
        </json-objects>

        <task>Merge the JSON objects in <json-objects> into one JSON object.</task>
        TXT;
    }

    public function messages(): array
    {
        return [
            new TextMessage(role: Role::User, content: $this->prompt()),
        ];
    }

    public function functions(): array
    {
        return array_filter([$this->forceFunction()]);
    }

    public function forceFunction(): ?InvokableFunction
    {
        return $this->shouldForceFunction
            ? new Extract(schema: $this->extractor->schema)
            : null;
    }

    public function shouldParseJson(): bool
    {
        return true;
    }
}
